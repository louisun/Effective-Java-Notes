# Item73. 避免使用线程组

除了「线程」、「锁」、「监视器」外，线程系统还提供了一个基本的抽象：线程组 `ThreadGroup`。其初衷是作为一种隔离 applet 小程序的机制，处于安全的考虑。但实际上它们没有真正履行承诺，安全性很差。



线程组并没有提供所提及的任何安全功能，那到底提供了什么功能？它们允许你同时把 Thread 的某些基本功能应用到「一组线程」上，其中一些基本功能已经废弃，剩下的也很少使用。



`ThreadGroup` 的 API 从线程安全性的角度看非常弱。为了得到一个线程组中的**活动线程列表**，你必须调用 `enumerate` 方法，它有一个数组参数，并且数组的容量必须足够大，以便容纳所有的活动线程。 `activeCount` 方法**返回一个线程组中活动线程的数量**。但是，一旦这个数组进行了分配，并传递给了 `enumerate` 方法，**就不保证原先得到的活动线程数仍是正确的**。如果线程数增加了，而数组太小， `enumerate` 方法就会悄然地忽略掉无法在数组中容纳的线程。

列出线程组中**子组**的 API 也有类似的缺陷。**虽然通过增加新的方法，这些问题都有可能得到修正，但是，它们目前还没有被修正，因为线程组已经过时了，所以实际上根本没有必要修正。**

在 Java 1.5 发行版本之前，有一种小功能只有 ThreadGroup API 才有：**当线程抛出未被捕捉的异常时， `ThreadGroup.uncaughtException` 方法是获得「控制权」的唯一方式。** 这项功能很有用，例如，**为了把堆栈轨迹定向到一个特定于应用程序的日志中**。然而，自从 Java 1.5 发行版本之后， `Thread` 的 `setUncaughtExceptionHandler` 方法也提供了同样的功能。

总而言之，线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。我们最好把线程组看作是一个不成功的试验，你可以忽略掉它们，就当它们根本不存在一样。如果你正在设计的一个类需要处理线程的逻辑组，或许就应该使用线程池 Executor。

