# Item66. 同步访问共享的可变数据



关键字 `synchronized` 可以保证在**同一时刻，只有一个线程执行某一个方法，或者一个代码块**。

许多程序员把同步的概念仅仅理解成一种「**互斥**」的方式，即当一个对象被一个线程修改的时候，可以**阻止另一个线程观察到对象内部不一致的状态**。这种观点是正确的，但同步的意义不止如此。

如果没有同步，**一个线程的变化就不能被其它线程看到**。同步不仅可以组织一个线程看到对象处于不一致的状态之中，还能保证进入同步的方法或同步代码块的每个线程，都看到「**由同一个锁保护的之前所有的修改结果**」。

Java 语言规范保证读写一个变得是「原子的 atomic」，除非变量类型是 `long` 或 `double`，否则保证返回的值是某个线程保存在该变量中的，即使多个线程在没有同步的情况下并发修改这个变量。

> 不能为了提高性能，读写原子数据时避免使用同步。在线程之间进行可靠通信或互斥访问，同步是必要的。这归因于 Java 的内存模型，它规定了一个线程所做的变化何时、如何变成对其他线程可见。



## 对共享的可变数据访问要进行同步



如果对「共享的可变数据访问」不使用同步，结果将非常可怕，即使这个变量是原子可读可写的。下面的例子是阻止一个线程妨碍另一个线程，类库提供了`Thread.stop`方法，但早已**不被建议使用**，它本质上是不安全的，使用它会导致数据被破坏。建议的做法是让一个线程「**轮询** poll」一个 `boolean` 域，这个域一开始为 `false`，但可通过第二个线程设置为 `true`，以表示第一个线程将终止自己。由于 `boolean` 域的读写操作都是源自的，程序员在访问这个域（`stopRequested`）的时候不再使用同步：





![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-27-10-55-21_r90.png)



从逻辑上看没什么问题，主程序在 1 秒钟后，将 `stopRequested` 设为 `true`，后台线程循环终止。但实际上，很可能后台线程永远不会停止，一直在循环，这个原因当然是后台线程 `while ` 循环一直为 `true`。



也就是说，由于没有同步，就无法保证后台线程「何时看到」主线程对 `stopRequested` 的值所做的改变。没有同步，虚拟机将这个代码：



```java
while(!done){
    i++;
}
```



**优化**成这样：



```java
if(!done){
    while(true){
        i++;
    }
}
```



这是可以接受的，这种优化叫做「**提升** hoisting」,正是 HotSpot 虚拟机的工作。这是一个「**活性失败** liveness failure」：程序无法前进。修正这个问题的一个方式是「**同步访问**」`stopRequested`域。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-27-11-20-47_r44.png)



我们把 `stopRequested` 的读方法、写方法都变成同步。事实上如果没有都被同步，同步也不会起作用。由于 `StopThread` 中被同步方法的动作即使「没有同步」也是「原子」的，也就是说将它变成同步的目的「**不是为了互斥访问**」，只是为了它的「**通信效果**」。



虽然循环的每个迭代中同步的开销很小，但还是有**更正确的替代方法**，更简洁、性能更好，即使用 `volatile` 关键字，其保证内存可见性：虽然 `volatile` 修饰符不执行「互斥访问」，但它可以保证任何一个线程在读取该域的时候都将看到最近刚刚被写入的值。

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-27-11-28-47_r51.png)





使用 `volatile` 的时候务必要小心，比如下面方法要生成序列号：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-27-11-30-35_r64.png)



前面说了，`volatile` 只保证内存可见性，即读的时候保证是最近刚被写入的值，但如果第 2 个线程在第 1 个线程读旧值和写新值的间隙读这个域，那么两个线程看到的是同一个值， 计算序号也是相同的。这叫做「**安全性失败** safety failure」，程序会出现计算错误。



修正一种的方法当然是对 `generateSerialNumber` 加 `synchronized` 修饰符，然后可以删除 `volatile`，这样保证增加值操作的原子性。要使这个方法更可靠，可以用 `long` 代替 `int`，或者在 `nextSerialNumber` 快要重叠时抛异常。



另一种方法就是用 `AtomicLong` 这个原子操作的类型，有可能比同步版本的 `generateSerialNumber` 做的更好。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-27-11-34-37_r44.png)



避免本条目中所讨论到的问题的「**最佳办法**」是「**不共享可变的数据**」。要么共享不可变的数据（Item 15），要么压根不共享。换句话说，**将可变数据限制在单个线程中。**如果采用这一策略，对它建立文档就很重要，以便它可以随着程序的发展而得到维护。深刻地理解正在使用的框架和类库也很重要，因为它们引入了你所不知道的线程。



**让一个线程在短时间内修改一个数据对象，然后与其他线程共享，这是可以接受的**，只同步共享对象引用的动作。然后**其他线程没有进一步的同步也可以读取对象，只要它没有再被修改**。这种对象被称作**事实上不可变的**（ effectively immutable）。**将这种对象引用从一个线程传递到其他的线程**被称作「**安全发布**」（safe publication）。安全发布对象引用有许多种方法：可以将它保存在静态域中，作为类初始化的一部分；可以将它保存在 `volatile` 域、 `final` 域或者通过正常锁定访问的域中；或者可以将它放到并发的集合中。



简而言之，**当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步**。**如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知**。未能同步共享可变数据会造成程序的**活性失败**（ liveness failure）和**安全性失败**（ safety failure）。这样的失败是最难以调试的。它们可能是间歇性的，且与时间相关，程序的行为在不同的 VM 上可能根本不同。**如果只需要线程之间的交互通信，而不需要互斥， volatile修饰符就是一种可以接受的同步形式，但要正确地使用它可能需要一些技巧**。