# Item70. 线程安全性和文档化

当一个类的实例或者静态方法被并发使用的时候，这个类的行为如何，是该类与其客户端程序建立的约定的重要组成部分。如果你没有在一个类的文档中描述其行为的并发性情况，使用这个类的程序员将不得不做出某些假设。如果这些假设是错误的，这样得到的程序就可能缺少足够的同步（见 Item 66），或者过度同步（见 Item 67）。



无论属于这其中的哪种情况，都可能会发生严重的错误。你可能听到过这样的说法：通过査看文档中是否出现 `synchronized` 修饰符，可以确定一个方法是否是线程安全的。**这种说法从几个方面来说都是错误的。**在正常的操作中， Javadoc 并没有在它的输出中包含 `synchronized` 修饰符，这是有理由的。因为在一个方法声明中出现 `synchronized` 修饰符，**这是个实现细节，并不是导出的API的一部分**。它并不一定表明这个方法是线程安全的，而且，“出现了 `synchronized` 关键字就足以用文档说明线程安全性”的这种说法隐含了一个错误的观念，即认为线程安全性是一种“要么全有要么全无”的属性。**实际上，线程安全性有多种级别**。一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。



下面的列表概括了常见的「线程安全性」的几种级别：

- 不可变：这个类的实例不可变，不需要外部同步，比如 `String`、`Long`、`BigInteger`
- 无条件的线程安全：这个类的实例可变，但是有足够的「内部同步」，实例可以被并发使用，无需外部同步，比如 `Random` 和 `ConcurrentHashMap`
- 有条件的线程安全： 除了有些方法为进行安全的并发使用而需要「外部同步」之外，这种线程的安全级别与无条件线程安全相同，这样的例子包括 `Collections.synchronized` 包装返回的集合，它们的迭代器（`iterator`）要求外部同步。
- 非线程安全：这个类的实例是可变的，为了并发使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。比如 `ArrayList`、`HashMap`
- 线程对立：这个类不能安全地被多个线程并发使用，即使所有方法的调用都被外部同步包围。线程对立的根源在于，没有同步地修改静态数据。这种类是因为没有考虑到并发性而产生的后果。幸运的是 Java 类库中「线程对立」的类或方法很少，`System.runFinalizersOnExit` 是线程对立的，但已经被废除了。



> 详情见《Java 并发编程实战》



在文档中描述一个「**有条件的线程安全类**」要特别小心。你必须指明**哪个调用序列需要外部同步**，还要指明为了执行这些序列，必须获得哪一把锁（极少的情况下是指哪几把锁）。**通常情况下，这是指作用在实例自身上的那把锁**，但也有例外。**如果一个对象代表了另一个对象的一个视图（view），客户通常就必须在后台对象上同步，以防止其他线程直接修改后台对象。**例如， `Collections.synchronizedMap `的文档应该有这样的说明：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-28-23-26-59_r57.png)





如果没有遵循这样的建议，就看造成不确定的行为。



类的线程安全说明通常放在它的文档注释中，但是带有特殊线程安全属性的「**方法**」则应该在它们自己的文档注释中说明它们的属性。没有必要说明枚举类型的不可变性。除非从返回类型来看已经很明显，否则静**态工厂必须在文档中说明被返回对象的线程安全性**，如 `Collections.synchronizedMap`（上述）所示。



当一个类承诺了“使用一个公有可访问的锁对象”时，就意味着允许客户端以原子的方式执行一个方法调用序列，但是，这种灵活性是要付出代价的。并发集合（如 `ConcurrentHashMap`和 `ConcurrentLinkedQueue`）使用的那种并发控制，并不能与高性能的内部并发控制相兼容。客户端还可以发起拒绝服务（ denial- of service）攻击，他只需超时地保持公有可访问锁即可。



为了避免这种拒绝服务攻击，应该使用一个「私有锁对象」来代替同步的方法（隐含着一个公有可访问锁）：



```java
private final Object lock = new Object();

public void foo(){
    synchronized(lock){
        ... 
    }
}
```



因为这个「私有锁」不能被这个类的客户端程序所访问，所以不可能妨碍对象的同步。实际上，我们正是在 Item 13 中建议，「**把锁对象封装在它所同步的对象中**」。



注意 lock 域被声明为 `final` 的，这样可以防止不小心改变它的内容，而导致不同步访问包含对象的悲惨后果 （Item 66）。这是在 Item 15 中的建议，将 `lock` 域的可变性减到最小。



私有锁对象模式只能用在「无条件线程安全」的类上，有条件线程安全类不能用这种模式，因为它们必须在文档中说明：在执行某些方法调用序列时，它们的客户端程序必须获得哪把锁。



私有锁对象模式特别适用于那些「专门为继承而设计」的类（见 Item 17），如果这种类使用其实例作为锁对象，子类很可能无意中妨碍基类的操作，反之亦然。处于不同的目的而使用相同的锁，子类和基类可能会相互“绊住对方的脚”。



简而言之，每个类都应该利用字斟句酌的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。 `synchronized` 修饰符与这个文档亳无关系。有条件的线程安全类必须在文档中指明“**哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁**”。如果你编写的是**无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法**。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。



