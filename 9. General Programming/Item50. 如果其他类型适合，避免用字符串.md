# Item50. 如果其他类型适合，避免用字符串



## 字符串不适合代替其他类型的值



只有当数据确实是文本信息时，才用字符串保存，否则尽量转换为适当的数值类型、布尔类型等。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-38-40_r29.png)







## 字符串不适合代替枚举类型



如 Item 30 中讨论的，枚举类型更适合表示枚举类型的常量。

## 字符串不适合代替聚集类型

聚集类型就是多种数据的聚合，类似一个数据结构或结构体。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-40-16_r18.png)



## 字符串不适合代替能力表（capabilities）



有时候字符串被用于对某种功能进行「授权访问」，例如设计一个提供现场局部变量的机制。这个机制提供的变量在每个线程中都有自己的值，在 Java 1.2 之前，没有 ThreadLocal 机制，所以要自己实现，有人会提出这样的方案：利用客户提供的字符串键，对每个线程局部变量的内容进行访问授权：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-58-22_r63.png)





问题在于，这些字符串键代表了一个「共享的全局命名空间」，要是使这种方法可行，key 必须是唯一的，如果一样则两个线程实际上共享了这个变量。



因此要用一个「不可伪造的键 unforgeable key」，有时候被称为「**能力 capability**」来替换字符串



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-15-01-19_r53.png)

还可以做的更好，实际上不需要静态方法，它们可以用键中的实例方法代替，这样这个键就不再是键，而是线程局部变量了。此时，这个不可实例化的顶层类也不需要再做任何实质性的工作，因此可以删除这个顶层类，并将内层的嵌套类命名为 `ThreadLocal`。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-15-01-43_r85.png)



这个 API 不是线程安全的，因为从线程局部变量得到它，必须将值从 Object 转换为实际的值，不可能使原始的基于 String 的 API 为线程安全点，要使基于 Key 的 API  类型安全的也很困难，但是，通过将 `ThreadLocal` 类泛型化，使这个 API 变成类型安全的就是很简单事了：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-15-01-55_r21.png)



粗略地将，这个就是 `java.util.ThreadLocal` 提供的 API。