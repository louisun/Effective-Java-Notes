# Item52. 通过接口引用对象

Item 40 中有个建议：应该使用「**接口类型**」，而是不是「**类**」作为引用参数。更一般地将，应该优先用「**接口**」而不是「**类**」来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就应该使用接口类型进行声明。



举个 `Vector` 的例子，它是 `List` 接口的一个实现，在声明对象时应该养成这样的习惯：



```java
List<Subscriber> subscribers = new Vector<Subscriber>();
```



而不是：

```java
Vector<Subscriber> subscribers = new Vector<Subscriber>();
```



> 使用接口作为类型的习惯，程序会变得更灵活。



当决定更换实现时，只需要改变构造器中类的名称（或者用一个不同的静态工厂）：



```java
List<Subscriber> subscribers = new ArrayList<Subscriber>();
```



周围的代码都可以继续工作，周围的代码并不知道原来的实现类型，所以不在意这些变化。



有一点值得注意：**如果原来的实现提供了某种特殊的功能，这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供相同的功能**。比如第一个声明的代码依赖于 `Vector` 的同步策略，那么在声明中用 `ArrayList` 代替 `Vector` 就是不正确的。如果依赖于实现的任何特殊属性，就要在声明变量的地方给这些需求建立相应的文档说明。



那么为什么要改变实现呢？因为**新的实现提供了更好的性能**，或者因为**它提供了期望得到的额外功能**。有个真实的例子与 `Threadlocal` 类有关。在内部，这个类在 `Thread` 中使用了一个包级私有的 `Map` 域，将每个线程的值（ per-thread values）与 `Threadlocal` 实例关联起来。在 1.3 发行版本中，这个域被初始化为 `HashMap`实例。在1.4发行版本中，Java 平台增加了一个新的、被称为 `IdentityHashMap`的「**专用Map实现**」。只需将初始化域的那一行代码改变为 `IdentityHashMap`，代替原来的 `HashMap`， `Threadlocal` 机制就会变快许多。 `ThreadLocal` 实现曾经一度发展为利用一个**没有实现 Map 接口**的高度优化过的存储结构，但是即使这样仍然不影响“通过接口引用对象”的这个观点。



如果把这个域声明为 `HashMap` 而不是`Map`，则无法保证只改变一行代码就足够了。如果客户端代码已经在`Map`接口之外使用了 `HashMap` 操作，或者把这个映射（Map）传递给了一个需要 `HashMap` 的方法，那么，若将该域改变为一个 `IdentityHashMap`，代码就不再能通过编译。用接口类型声明域“让你保持诚实”。



如果没有合适的接口存在，完全可以用类而不是接口来引用对象。比如「值类」：`String`、`BigInteger`。值类很少会用多个实现编写，它们通常是 `final` 的，并且很少有对应的街扩。使用值类作为参数、变量、域、返回类型是再合适不过了。更一般地，**如果具体类没有相关联的接口，不管它是否表示一个值，都没有别的选择，只有通过它的类来引用它的对象。** `Random` 类就是这种情形。



不存在适当接口类型的第二种情形是，**对象属于一个框架，而框架的基本类型是类，不是接口**。如果对象属于这种「**基于类的框架**」，就应该用相关的「**基类**」来引用这个对象，而不是它的实现类。比如 `java.util.TimerTask` 抽象类就属于这种情形。



不存在适当接口类型的最后一种情形是：**类实现了接口，但是它提供了「接口中不存在的额外方法」**——例如 `LinkedHashMap`。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例，很少应该被用作参数类型。



以上这些例子并不全面，而只是代表了一些“适合于用类来引用对象”的情形。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活；如果不是，则使用类层次结构中提供了必要功能的最基础的类。

