# **Item49. 基本类型优先于集装箱类型**

Java 的类型系统由 2 部分组成：

1. 基本类型（**primitive**）：`int`、`double`、`boolean`等
2. 引用类型（**reference type**）：`String`、`List`等



每个基本类型有一个对应的引用类型，称作「**装箱基本类型 boxed primitive**」，比如 `Integer`、`Double`、`Boolean`等。



「自动装箱 autoboxing」、「自动拆箱 auto-unboxing」，这些特性「**模糊了但并没有完全抹去**」基本类型和装箱类型的区别。并且要对这两种类型进行谨慎的选择。



## 基本类型和装箱类型的 3 个区别



1. 基本类型只有值， 装箱类型则具有「**与它们的值不同**」的「**同一性**」，即两个装箱类型可以具有「**相同的值**」和「**不同的同一性**」
2. 基本类型只有功能完备的值，装箱类型除了对应基本类型所有的功能值外，还有非功能值：`null`
3. 基本类型通常比装箱类型更省「**时间和空间**」



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-14-36_r31.png)

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-23-42_r8.png)



这个比较器被设计用来表示 `Integer` 值的递增数字顺序，这里只是展示，实际不需要编写一个自然顺序的比较器。上面这个例子的这样会出问题：`naturalOrder.compare(new Integer(42), new Integer(42))`，这两个实例代表值 42，表达式的值应该是 0，但是结果是 1，意味着第一个 `Integer` 大于 第二个。



问题出在哪里？对表达式 `i < j` 执行计算会导致被 `i` 和 `j` 引用的 `Integer` 实例被「**自动拆箱**」，也就是说提取了它们的基本类型值。但第二个表达式中 `i == j`，则是在对象引用上执行「同一性比较」，两个对象是不同的实例，因此是不想等待 ，所以比较器错误地返回 1。

> 对装箱基本类型运用 `==` 几乎总是错误的。



解决方法：就是先把对象的值提取出来（自动拆箱）到局部变量。

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-25-57_r17.png)



下面考虑这个代码：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-26-57_r29.png)

结果不是打印 `Unbelievable`，而是抛出一个 `NullPointerException` 异常，问题在于 `i`  是装箱类型，**当一项操作中「混合使用基本类型和装箱基本类型」，装箱基本类型会自动拆箱。** 这种情况无一例外，如果 `null`对象引用被自动拆箱，就会得到上面的异常。修正上面的代码只要变成 `int` 基本类型就行了。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-33-07_r12.png)

这段程序运行比较慢，这是因为不小心将局部变量（`sum`）声明为装箱基本类型「`Long`」，而不是基本类型 `long`，变量会「反复地进行装箱和拆箱」，导致明显的性能下降。



## 什么时候使用装箱基本类型



1. 集合中的元素、键、值，不能讲基本类型放到集合中
2. 参数化类型（`ThreadLocal<Integer>`），必须使用装箱基本类型
3. 在进行反射的方法调用时，必须使用装箱基本类型



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-24-14-36-40_r54.png)



