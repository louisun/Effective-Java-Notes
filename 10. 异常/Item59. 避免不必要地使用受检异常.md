# Item59. 避免不必要地使用受检异常

受检异常是 Java 的一项很好的特性，与返回代码不同，它们强迫程序员处理异常的条件，大大增强了可靠性。但过分使用受检异常会使 API 用起来很不方便。如果方法抛出一个或多个受检异常，调用该方法的代码就必须在一个或多个 `catch` 块中处理这些异常，或者它必须声明它抛出这些异常，并让它们传播出去。无论哪种方法都是不可忽视的负担。



如果正确地使用 API 并不能阻止这种异常条件的产生，并且一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担就被认为是正当的。除非这两个条件都成立，否则更适合于使用**未受检的异常**。作为一个「石蕊」测试，你可以试着问自己：程序员将如何处理该异常。下面的做法是最好的吗?

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-17-36-57_r51.png)



如果使用 API 的程序员无法做比这更好，那么用「未受检」异常困难更合适。这种例子就是 `CloneNotSupportedException`，它是被 `Object.clone` 抛出来的，而 `Object.clone` 应该只是在实现了 `Cloneable` 的对象上才可以被调用。在实践中，`catch` 块几乎总是具有「断言失败」的特征。异常受检的本质并没有为程序员提供任何好处，它反而需要付出努力，还使程序更为复杂。



被一个方法单独抛出的受检异常，会给程序员带来非常高的额外负担。如果这个方法还有其他的受检异常，它被调用的时候一定已经出现在一个try`块中`，所以这个异常只需要另外一个 `catch` 块。如果方法只抛出单个受检的异常，仅仅一个异常就会导致该方法不得不外于 `try` 块中。在这些情况下，应该问自己，是否有别的途径来避免使用受检的异常。



## 把checked异常变成unchecked异常



「**把受检的异常变成未受检的异常**」的一种方法是，把这个抛出异常的方法分成 2 个方法，其中第一个方法返回一个 `boolean`，**表明是否应该抛出异常**。这种 API 重构，把下面的调用序列：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-17-42-39_r33.png)



变成：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-17-42-53_r49.png)



这种重构并不总是恰当的，但是凡是在恰当的地方，都会使 API 用起来更舒服。



如果程序员知道调用会成功，或不介意由于调用失败导致线程终止，这种重构还允许直接：



```java
obj.action(args);
```



如果你怀疑这个简单的调用序列是否合乎要求，这个 API 重构可能就是恰当的。这种重构之后的 API 在**本质上等同于 Item 57 中的「状态测试方法」**，并且，同样的告诫依然适用：如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在 `actionPermitted` 和 `action` 这两个调用的时间间隔之中，对象的状态有可能会发生变化。如果单独的 `actionPermitted`方法必须重复 `action` 方法的工作，出于性能的考虑，这种 API 重构就不值得去做。

