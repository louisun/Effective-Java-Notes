# Item61. 抛出与抽象对应的异常

如果「**方法抛出的异常**」与它「**所执行的任务**」没有任何关系，这种情形令人不知所措。**当方法传递由低层抽象抛出的异常时，往往会发生这种情况。**除了令人感到困惑，也让实现细节污染了更高层的 API。如果高层的实现在后续的发行版本中发生了变化，它锁抛出的异常也会跟着发生变化，从而潜在地破坏现有的客户端程序。



## 异常转译

为了避免这个问题，**更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常**。这种做法被称为「**异常转译 exception translation**」：



```java
try {
    ... // 捕获低层抽象的异常
}
catch (LowerLevelException e){
    throw new HigherLevelException(...);
}
```



下面的异常转译例子取自 `AbstractSequentialList` 类，该类是 `List` 即可的一个「骨架实现 skeletal implementation」（Item 18），在这个例子中，按照 `List<E>` 接口中的 `get` 方法的规范要求，异常转译是必须的：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-22-13-46_r68.png) 





## 异常链



一种特殊的异常转译形式称为「**异常链 exception chaining**」，如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。低层异常（原因）被传到高层的异常，高层的异常提供访问方法（`Throwablel.getCause`）来获得低层异常：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-22-17-04_r78.png)



高层异常的构造器将原因转到「**支持链 chaining-aware**」的超级构造器，因此它最终被传给 `Throwable` 的其中一个运行异常链的构造器，例如 `Throwable(Throwable t)`：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-22-18-56_r96.png)



大多数标准的异常都有支持链的构造器。对于没有支持链的异常，可以利用 `Throwable` 的 `initCause` 方法**设置原因**。异常链不仅让你可以通过程序（用 `getCause`）访问原因，它还可以**将原因的堆栈轨迹集成到更高层的异常中**。



## 总结



如果无法避免低层异常，次选方案是，**让更高层来悄悄地绕开这些异常，从而将高层方法的调用者与低层的问题隔离开来**。在这种情况下，可以用某种适当的记录机制（如`java.util.logging`）将异常记录下来。这样有助于管理员调査问题，同时又将客户端代码和最终用户与问题隔离开来。



总而言之，如果不能阻止或者处理来自更低层的异常，一般的做法是使用**异常转译**，除非低层方法碰巧可以保证它抛出的所有异常**对高层也合适**才可以**将异常从低层传播到高层**。异常链对髙层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获底层的原因进行失败分析 Item 63。

