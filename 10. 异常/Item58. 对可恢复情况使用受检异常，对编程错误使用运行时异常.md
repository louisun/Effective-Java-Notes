# Item58. 对可恢复情况使用受检异常，对编程错误使用运行时异常

> 「未受检」、「受检」这样的名词，我每次听到都觉得很别扭，一下子可能联想不到相关的概念。用「不用检查」、「需要检查」来表示多么直观，或者直接用 chekced、unchecked 也行啊。



Java 提供了 3 种「**可抛出结构 throwable**」：

1. 受检的异常 checked exception
2. 运行时异常 runtime exception
3. 错误 error



> `RuntimeException` 为非受检异常，字面意思就是不需要进行检查处理的异常，什么算是非受检异常呢，你可以认为因为人为原因出现的异常都可以算到非受检异常下，比如说空指针，比如说下标越界，这些都是可避免的。但是有些异常不是程序员可控的，比如说IO异常，文件找不到异常，这些必须需要做处理才可以，要么抛出，要么捕获。**非受检异常的好处就是既然这些异常都是可避免的，那么就不需要显式的捕获或抛出，也保证了代码不被异常所污染**



什么时候适合用哪种结构，会有一些困惑，不是绝对的，但有一般性的原则。



## Checked OR Unchecked

在决定是用「受检异常」还是「未受检」异常时，主要原则是：**如果期望调用者能够适当地「恢复（即处理异常）」，那么应该用「受检异常」**。通过抛出「受检异常」，强迫**调用者**在一个 `catch` 子句中处理该异常，或者的将它传播出去，因此，方法中声明要抛出的每个受检异常，都是对 API 用户的一种潜在指示：**与异常相关联的条件是调用这个方法的一种可能的结果**。



API 的设计者让 API 用户面对受检的异常，以此强制用户从这个异常条件中恢复。用户可以忽视这样的强制要求，只需要捕获异常并忽略即可，但往往不是一个好办法。



## 未受检：RuntimeException、Error



有两种 `unchecked` 的可抛出结构：运行时异常 Runtime Exception 和错误 Error，*在行为上两者是等同的*：都不是「**需要**」也不应该被「**捕获**」的可抛出结构。**如果程序抛出未受检的异常或错误，往往就属于不可恢复的情形**，继续执行下去有害无益。如果程序没有捕捉到这样的可抛出结构，将会导致当前线程停止 halt，并出现适当的错误信息。



用运行时异常来表明「编程错误」，大多数的运行时异常都表示「**前提违例** precondition violation」：即 API 的客户没有遵守 API 规范建立的约定。例如：数组访问的约定指明了数组下标值必须在 0 和 length 减 1 之间。`ArrayIndexOutOfBoundsException` 表明这个前提被违反了。





虽然 JLS（Java语言规范）并没有要求，但是按照惯例，「`Error 错误`」往往被 JⅤM 保留用于表示「**资源不足、约束失败，或者其他使程序无法继续执行的条件**」。由于这已经是个几乎被普遍接受的惯例，因此**最好不要再实现任何新的Erorr`子类`**。因此，你实现的**所有未受检的拋出结构都应该是 `RuntimeException`的子类**（直接的或者间接的）。



## 不要定义非Exception、RuntimeException、Error的子类



想要定义一个抛出结构，不是 `Exception`、`RuntimeException` 或 `Error` 的子类，也是可能的。JLS 没有直接规定这样的抛出结构，而是隐式指定了：从行为意义上讲它们等同于普通的「受检异常」（即 `Exception` 的子类，但不是 `RuntimeException` 的子类 ）。什么时候应该定义这样的 `Throwable` 呢？永远也不会用到。它们与普通的受检异常相比没有任何益处，只会困扰 API 的用户。





## 总结



总之，对于「**可恢复**」的情况，使用「**受检异常**」；对于「**程序错误**」，使用「**运行时异常**」。当然情况不总是那么容易分明。比如资源枯竭的情形，可能是由于程序错误引起的，比如分配了一块不合理的过大的数组，也可能确实是由于资源不足引起的。如果资源枯竭是由于临时的短缺，或临时需求太大所造成的，这种情况可能是可恢复的。API 设计者要判断这样的资源枯竭是否允许恢复。如果相信一种情况可能允许恢复，就使用「受检」异常；如果不是，则使用「运行时」异常。如果不清楚是否有可能恢复，最好使用「未受检异常」（Item 59）。



API的设计者往往会忘记，**异常也是个完全意义上的对象，可以在它上面定义任意的方法**。这些方法的主要用途是为「**捕获异常的代码而提供额外的信息**」，特别是「**关于引发这个异常条件的信息**」。如果没有这样的方法，程序员必须要懂得如何解析「**该异常的字符串表示法**」，以便获得这些额外信息。这是**极为不好的做法**。类很少会指定它们的字符串表示法中的细节，因此，不同的实现，不同的版本，字符串表示法会大相径庭。因此，「**解析异常的字符串表示法**」的代码可能是不可移植的，也是非常脆弱的。





因为「**受检异常**」往往指明了**可恢复的条件**，所以，**对于这样的异常，提供一些辅助方法尤其重要**，通过这些方法，调用者可以获得一些有助于恢复的信息。例如，假设因为用户没有储存足够数量的钱，他企图在一个收费电话上进行呼叫就会失败，于是抛出受检的异常。**这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，从而可以将这个数值传递给电话用户。**



