# Item57. 只针对异常的情况才使用异常



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-26-10-42-44_r46.png)



以上代码的作用并不明显，滥用了异常，以捕获下标越界异常的方式来终止无限循环。下面代码则一眼就能明白作用：



```java
for(Mountain m: range)
	m.climb();
```



那么，为什么有人会优先使用基于异常的模式，而不是用行之有效的模式呢？这是被误导了，他**们企图利用 Java 的错误判断机制来提高性能，因为ⅤM对每次数组访问都要检查越界情况，所以他们认为正常的循环终止测试被编译器隐藏了**，但在 `for-each` 循环中仍然可见，这无疑是多余的，应该避免。这种想法有 3 个错误：

1. 因为**异常机制的设计初衷是用于不正常的情形**，所以很少会有 JVM 实现会试图对它们进行优化，使得与显示的测试一样快速。
2. 把代码放在 `try-catch` 块中反而阻止了现代 JVM 实现本来可能要执行的某些特定优化
3. 对数组进行遍历的标准模式并不导致冗余的检查。有些现代的 JVM 实现会将它们优化掉。



基于异常的循环模式不仅模糊了代码的意图，降低了它的性能，而且不能保证正常工作。



> 异常应该只用于异常的情形下，永远不应该用于正常的控制流。



## API 设计：状态测试、可识别返回值

设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有「状态相关（ state- dependent）」的方法，即只有在特定的「**不可预知的条件下**」才可以被调用的方法，这个类往往也应该有个单独的「**状态测试（state-testing）**」方法，即**指示是否可以调用这个状态相关的方法**。例如， `Iterator` 接口有一个**状态相关**的 `next` 方法，和相应的**状态测试方法** `hasNext`。这使得利用传统的 for循环（以及`for-each`循环，在这里，是在内部使用 `hasNext`方法）对集合进行迭代的标准模式成为可能：



```java
for(Iterator<Foo> i = collection.iterator(); i.hasNext()){
    Foo foo = i.next();
    ...
}
```



如果 `Iterator` 缺少 `hasNext` 方法，客户端被迫改用以下做法：



```java
// 迭代集合时不要用这种丑陋的代码
try{
    Iterator<Foo> i = collection.iterator();
    while(true){
        Foo foo = i.next();
    }
}
catch (NoSuchElementException e){
    ...
}
```



这应该非常类似于本条目刚开始时对数组进行迭代的例子。除了代码繁琐且令人误解之外，这个基于异常的模式可能执行起来也比标准模式更差，并且还可能掩盖系统中其他不相关部分中的Bug。





另一种提供单独的状态测试方法的做法是，如果「**状态相关的**」方法被调用时，该对象处于不适当的状态之中，它就会返回一个「**可识别的值**」，比如 `null`。这种方法对于 `Iterator` 而言并不合适，因为 `null` 是`next`方法的合法返回值。





对于「**状态测试方法**」和「**可识别的返回值**」这两种做法，有些指导原则可以帮助你在两者之中做出选择：

1. 如果对象将在**缺少外部同步**的情况下**被并发访问**，或者可被外界**改变状态**，使用「**可被识别的返回值**」可能是很有必要的，因为在调用「**状态测试**」方法和调用对应的「**状态相关**」方法的时间间隔之中，**对象的状态有可能会发生变化。**
2. 如果单独的「**状态测试**」方法必须重复「**状态相关**」方法的工作，从「**性能的角度**」考虑，就应该使用可被识别的返回值。
3. 如果所有其他方面都是等同的，那么「**状态测试**」方法则**略优于**「**可被识别的返回值**」。它提供了**更好的可读性**，对于使用不当的情形，可能**更加易于检测和改正**：如果忘了去调用状态测试方法，状态相关的方法就会抛出异常，使这个Bug变得很明显，如果忘了去检查可识别的返回值，这个Bug就很难会被发现。



总而言之，异常是为了在异常情况下使用而设计的，不要讲它们用于普通的控制流，也不要编写迫使它们这么做的 API。

