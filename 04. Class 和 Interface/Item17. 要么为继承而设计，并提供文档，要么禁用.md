# Item17. 要么为继承而设计，并提供文档，要么禁用



第16条提醒我们，对于不是为了继承而设计、并且没有文档说明的“外来”类进行子类化是多么危险。那么对于专门为了继承而设计并且具有良好文档说明的类而言，这又意味着什么呢？

首先，该类的文档必须精确地描述覆盖毎个方法所带来的影响。**换句话说，该类必须有文档说明它可覆盖（ `overridable`）的方法的自用性（`self-use`）**。对于每个公有的或受保护的方法或者构造器，它的文档必须指明该方法或者构造器调用了哪些可覆盖的方法，是以什么顺序调用的，每个调用的结果又是如何影响后续的处理过程的（所谓可覆盖（ `overridable`）的方法，是指非`final`的，公有的或受保护的）。更一般地，类必须在文档中说明，在哪些情况下它会调用可覆盖的方法。例如，后台的线程或者静态的初始化器（ `initializer`）可能会调用这样的方法。

调用可覆盖方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为“Implementation Requirements,”，由Javadoc标签`@implSpec`生成。 本节介绍该方法的内部工作原理。 下面是从`java.util.AbstractCollection`类的规范中拷贝的例子：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2018-11-23-14-29-33_r64.png)

`@implSpec`标签是在Java 8中添加的，并且在Java 9中被大量使用。这个标签应该默认启用，但是从Java 9开始，除非通过命令行开关`-tag "apiNote:a:API Note:”`，否则Javadoc实用工具仍然会忽略它。



关于程序文档有句格言：**好的 API 文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。**那么，上面这种做法是否违**背了这句格言呢**?是的，它确实违背了!这正是继承破坏了封装性所带来的不幸后果。**所以，为了设计一个类的文档，以便它能够被安全地子类化，你必须描述清楚那些有可能未定义的实现细节**。



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2018-11-23-14-32-55_r38.png)