# v3-Item85. 优选选用其他方式来进行Java序列化



当「序列化」在 1997 年被添加到Java时，它被认为有点风险。该方法当时已经在一种研究语言（Modula-3）中尝试过，但从未用在生产语言上。虽然对一部分程序员而言，用很少的代价使用分布式对象是有吸引力的，但代价是隐形的构造函数、和API与实现之间模糊的界限，可能存在正确性、性能、安全性和可维护方面的问题。支持者认为这些好处超过了风险，但历史已经证明不是这样。



序列化的一个基本问题是它的「攻击面 attack surface」太大无法保护并且不断增长：通过在`ObjectInputStream` 上调用`readObject`方法来反序列化对象图。**这个方法本质上是一个神奇的构造函数，只要类型实现了`Serializable`接口，就可以在类路径上实例化几乎任何类型的对象。**在反序列化字节流的过程中，此方法可以从任何这些类型执行代码，因此所有这些类型的代码都是攻击面的一部分。

攻击面包括 Java 平台库中的类，第三方库（如 Apache Commons Collections）和应用程序本身。即使您遵守所有相关的最佳实践并成功编写无法攻击的可序列化类，**您的应用程序仍可能容易受到攻击**。引用CERT协调中心技术经理Robert Seacord的话：

> Java 反序列化是一个明显且存在的危险，因为它直接被应用程序广泛使用，并间接地由Java子系统（如`RMI`（远程方法调用），`JMX`（Java管理扩展）和`JMS`（Java消息系统））广泛使用。**不受信任的流的反序列化**可能导致远程代码执行（RCE），拒绝服务（DoS）以及一系列其他漏洞利用。应用程序即使没有做错也容易受到这些攻击。



攻击者和安全研究人员研究 Java 库和常用第三方库中的**可序列化类型**，查找**在反序列化期间调用的执行潜在危险活动的方法。这种方法称为小工具**。可以一起使用多个小工具来形成小工具链。**有时会发现一个足够强大的小工具链，允许攻击者在底层硬件上执行任意本机代码，只要有机会提交精心设计的字节流进行反序列化。**

在不使用任何小工具的情况下，您可以通过使用「需要很长时间反序列化的短流」的反序列化来轻松地发起**拒绝服务攻击**。这种流被称为**反序列化炸弹**。这是 Wouter Coekaerts 的一个例子，它只使用哈希集和字符串：



```java
// Deserialization bomb - deserializing this stream takes forever
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo"); // Make t1 unequal to t2
        s1.add(t1); s1.add(t2);
        s2.add(t1); s2.add(t2);
        s1 = t1;
        s2 = t2;
    } 
    return serialize(root); // Method omitted for brevity
}
```



对象图由 201 个`HashSet`实例组成，每个实例包含 3 个或更少的对象引用。整个流的长度为 5,744 字节，但是将其反序列化的世界可以等到太阳燃尽。为什么要花如此久时间反序列化？主要问题在于**反序列化 `HashSet` 实例需要计算其元素的哈希码。** 根哈希集的 2 个元素本身是包含 2 个哈希集元素的哈希集，每个哈希集元素包含2个哈希集元素，依此类推，深度为100个级别。因此，反序列化集会导致hashCode方法被调用超过 2 的 100次幂次。除了反序列化永远存在的事实之外，解串器没有任何迹象表明任何问题。产生的对象很少，并且堆栈深度是有界的。

那么你能做些什么来抵御这些问题呢？每当您反序列化您不信任的字节流时，您就会迎接攻击。**避免序列化漏洞利用的最佳方法是永远不要反序列化任何东西。**用1983年电影“战争游戏”中名为约书亚的电脑的话来说，“**唯一的胜利就是不玩。**”



## 其他将对象和字节序列转换的机制



**没有理由在你编写的任何新系统中使用 Java 序列化**。还有其他在对象和字节序列之间进行转换的机制，可以避免Java序列化的许多危险，同时提供许多优势，例如**跨平台支持，高性能，大型工具生态系统以及广泛的专业知识社区**。在本书中，我们将这些机制称为「**跨平台结构化数据表示**」。虽然其他人有时将它们称为序列化系统，但本书避免了这种用法，以防止与 Java 序列化混淆。

**这些表示的共同之处在于它们比 Java 序列化简单得多**。它们不支持任意对象图的自动序列化和反序列化。相反，它们支持由一组「**属性-值对**」组成的简单结构化数据对象。仅支持少数原始数组和数组数据类型。这种简单的抽象结果足以构建极其强大的分布式系统，并且足够简单，可以避免从一开始就困扰Java序列化的严重问题。

领先的跨平台结构化数据表示是`JSON`和 `Protocol Buffers`，也称为 `protobuf`。 `JSON` 由 Douglas Crockford设计用于浏览器 - 服务器通信，并且协议缓冲器由Google设计用于在其服务器之间存储和交换结构化数据。即使这些表示有时被称为语言中性，`JSON`最初是为JavaScript开发的，而`protobuf`是为C ++开发的；这两种表述都保留了其起源的痕迹。

`JSON`和`protobuf`之间最显着的**区别是`JSON`是基于文本的，人类可读的，而`protobuf`是二进制的，效率更高；并且JSON完全是数据表示，而 protobuf 提供模式（类型）来记录和适当的用法。** 尽管protobuf比JSON更有效，但JSON对于基于文本的表示非常有效。虽然protobuf是二进制表示，但它确实提供了一种替代文本表示，用于需要人类可读性的用途（pbtxt）。



## 处理遗留的序列化工作

**如果您无法完全避免Java序列化**，可能是因为您在需要它的遗留系统的上下文中工作，那么您的下一个最佳选择是**永远不会反序列化不受信任的数据。特别是，您永远不应接受来自不受信任来源的 RMI 流量**。 Java的官方安全编码指南说“不受信任的数据的反序列化本质上是危险的，应该避免。

如果您无法避免序列化，并且您不确定要反序列化的数据的安全性，请使用Java 9中添加的对象反序列化过滤并向后移植到早期版本（`java.io.ObjectInputFilter`）。此工具允许您指定在反序列化之前应用于数据流的过滤器。它以类粒度运行，允许您接受或拒绝某些类。默认接受类并拒绝潜在危险类列表称为黑名单;默认情况下拒绝类并接受假定安全的列表称为白名单。喜欢将白名单列入黑名单，因为黑名单只能保护您免受已知威胁。名为Serial Whitelist Application Trainer（SWAT）的工具可用于为您的应用程序自动准备白名单。**过滤工具**还可以保护您免受过多的内存使用和过深的对象图，但它不会保护您免受如上所示的序列化炸弹的攻击。

**不幸的是，序列化在Java生态系统中仍然普遍存在**。 如果您要维护基于Java序列化的系统，**请认真考虑迁移到跨平台的结构化数据表示，即使这可能是一项耗时的工作**。 实际上，您**可能仍然发现自己必须编写或维护可序列化的类。 编写一个正确，安全，高效的可序列化类需要非常小心。** 本章的其余部分提供了有关何时以及如何执行此操作的建议。

总之，序列化是危险的，应该避免。 如果您从头开始设计系统，请使用跨平台的结构化数据表示，例如JSON或protobuf。 不要反序列化不受信任的数据。 如果必须这样做，请使用对象反序列化过滤，但请注意，不能保证阻止所有攻击。 避免编写可序列化的类。 如果你必须这样做，请谨慎行事。