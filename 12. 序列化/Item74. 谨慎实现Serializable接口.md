# Item74. 谨慎实现Serializable接口

想要使一个类的实例可序列化，非常简单，只要在声明中加入「`implements Serializable`」。虽然使类可被序列化的直接开销很低（忽略不计），但为了序列化而付出的长期开销是实实在在的。





## 实现 Serializable 的代价：一



**实现 `Serializable` 接囗而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。**如果一个类实现了 `Serializable` 接口，它的字节流编码（或者说序列化形式）就变成了它的导出的 API 的一部分。一旦这个类被广泛使用，往往必须永远支持这种序列化形式，就好像你必须要支持导出的 API 的所有其他部分一样。如果你不努力设计一种自定义的序列化形式（，而仅仅接受了默认的序列化形式，这种序列化形式将被永远地束缚在该类最初的内部表示法上。换句话说，如果你接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API的部分，这**不符合“最低限度地访问域”的实践准则**，从而它就失去了作为信息隐藏工具的有效性。

**如果你接受了默认的序列化形式，并且以后又要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。**客户端程序企图用这个类的旧版本来序列化一个类，然后用新版本进行反序列化，结果将导致程序失败。在改变内部表示法的同时仍然维持原来的序列化形式（使用 `ObjectOutputStream.putFields` 和 `ObjectInputStream.readFields`），这也是可能的，但是做起来比较困难，并且会在源代码中留下一些明显的隐患。因此，**你应该仔细地设计一种高质量的序列化形式，并且在很长时间内都愿意使用这种形式。**这样做将会增加开发的初始成本，但这是值得的。设计良好的序列化形式也许会给类的演变带来限制;但是设计不好的序列化形式则可能会使类根本无法演变。

序列化会使类的演变受到限制，这种限制的一个例子与**流的唯一标识符**（stream uniqueidentifier）有关，通常它也被称为**序列版本 UID**（ serial version UID）**。每个可序列化的类都有一个唯一标识号与它相关联。**如果你没有在一个名为 `serialVersionuID` 的私有静态 `final` 的`long`域中显式地指定该标识号，系统就会自动地根据这个类来调用一个复杂的运算过程，从而在运行时产生该标识号。这个自动产生的值会受到**类名称**、它**所实现的接口的名称**、以及所有**公有的和受保护的成员的名称**所影响。如果你通过任何方式改变了这些信息，比如，**增加了个不是很重要的工具方法，自动产生的序列版本 UID 也会发生变化**。因此，如果你没有声明一个显式的序列版本UID，兼容性将会遭到破坏，在运行时导致 `InvalidclassException` 异常。



## 实现 Serializable 的代价：二

**实现 Serializable的第二个代价是，它增加了岀现 Bug 和安全漏洞的可能性。**通常情况下对象是利用构造器来创建的；序列化机制是一种语言之外的对象创建机制。无论你是接受了默认的行为，还是覆盖了默认的行为，**反序列化机制都是一个「隐藏的构造器」**，具备与其他构造器相同的特点。因为**反序列化机制中没有显式的构造器，所以你很容易忘记要确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，并且不允许攻击者访问正在构造过程中的对象的内部信息。**依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问。



### 实现 Serializable 的代价：三

**实现 Serializable 的第三个代价是，随着类发行新的版本，相关的测试负担也增加了**。当个可序列化的类被修订的时候，很重要的一点是，要检查是否可以「**新版本中序列化一个实例，然后在旧版本中反序列化**」，反之亦然。因此，测试所需要的工作量与“可序列化的类的数量和发行版本号”的乘积成正比，这个乘积可能会非常大。这些测试不可能自动构建，因为除了**二进制兼容性**以外，你还必须测试**语义兼容性**。换句话说，你必须既要确保“序列化一反序列化”过程成功，也要确保结果产生的对象真正是原始对象的复制品。可序列化类的变化越大，它就越需要测试。如果在最初编写一个类的时候，就精心设计了自定义的序列化形式，测试的要求就可以有所降低，但是也不能完全没有测试。



## 其他



实现 `Serializable` 接口并不是一个很轻松就可以做出的决定。**它提供了一些实在的益处：如果一个类将要加入到某个框架中，并且该「框架依赖于序列化来实现对象传输」或者「持久化」对于这个类来说，实现 Serializable 接口就非常有必要。**更进一步来看，**如果这个类要成为另个类的一个组件，并且后者必须实现 Serializable 接口，若前者也实现了 Serializable 接口它就会更易于被后者使用**。然而，有许多实际的开销都与实现 Serializable 接口有关。每当你实现一个类的时候，都需要权衡一下所付出的代价和带来的好处。**根据经验，比如`Date`和`BigInteger`这样的值类应该实现 Serializable，大多数的集合类也应该如此。**

**代表活动实体的类，比如线程池，一般不应该实现 Serializable。**



**为了「继承而设计」的类应该尽可能少地去实现 Serializable接口，用户的接口也应该尽可能少地继承 Serializable 接口**。如果违反了这条规则，扩展这个类或者实现这个接口的程序员就会背上沉重的负担。*然而在有些情况下违反这条规则却是合适的。例如，如果一个类或者接口存在的目的主要是为了参与到某个框架中，该框架要求所有的参与者都必须实现 Serializable接口，那么，对于这个类或者接口来说，实现或者扩展 Serializable接口就是非常有意义的。*



在为了继承而设计的类中，真正实现了 `Serializable` 接口的有 `Throwable`类、 `Component`和`HttpServlet`抽象类。因为 `Throwable` 类实现了 `Serializable` 接口，所以 `RMI` 的异常可以从服务器端传到客户端。 `Component` 实现了 `Serializable`接口，因此 GUI 可以被发送、保存和恢复。`HttpServlet`实现了 `Serializable` 接口，因此会话状态可以被缓存。



如果你实现了一个「**带有实例域**」的类，它是**可序列化**和**可扩展**的，你就应该担心这样一条告诫：如果类有一些约束条件，**当类的实例域被初始化成它们的默认值时**（整数类型为 `0`， `boolean` 为 `false`，对象引用类型为 `null`），**就会违背这些约束条件，这时候你就必须给这个类添加这个 `readobjectNoData` 方法**：



```java
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("Stream data required");
}
```



Java1.4 版本中就增加了这个 `readobjectNoData` 方法，还包含了一些冷僻的用例，**包括给现有的可序列化类添加可序列化的超类**。如果你有兴趣，可以在序列化规范中找到详细的信息。



有一条告诫与“**不要实现 `Serializable`接口**”有关。如果一个「专门为了继承而设计」的类不是可序列化的，就不可能编写出可序列化的子类。特别是，**如果「超类没有提供可访问的无参构造器」，子类也不可能做到可序列化**。因此，**对于为继承而设计的不可序列化的类，你应该考虑提供一个无参构造器**。这通常并不需要付出特别的努力，因为许多为继承而设计的类都不具有状态，但是情况并不总是这样的。

「**内部类**」不应该实现 Serializable，**它们使用编译器产生的「合成域」来保存外围实例的引用**，以及保存「来自外围作用域的局部变量值」。由于「这些域如何定义到类定义中」没有明确的规定，就报销没有指定「匿名类」和「局部类」的名称一样，因此「内部类」的默认序列化形式是定义不清楚的。然而「静态成员类」缺可以实现 `Serializable`接口。



简而言之，千万不要认为实现 `Serializable` 接口会很容易。除非一个类在用了一段时间之后就会被抛弃，否则，**实现 `Serializable` 接口就是个很严肃的承诺，必须认真对待**。如果一个类是为了继承而设计的，则更加需要加倍小心。对于这样的类而言，在“允许子类实现 `Serializable` 接口”或“禁止子类实现 `Serializable` 接口”两者之间的一个折衷设计方案是，**提供一个可访问的无参构造器**。这种设计方案允许（但不要求）子类实现 Serializable 接口。