# Item77. 对于实例控制，枚举类型优先于readResolve



Item 3 讲述了 `Singleton` 模式，并且给出了以下 `Singleton` 类的实例，这个类限制了对其构造器的访问，以确保永远只创建一个实例：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-08-20_r64.png)



正如在 Item 3 中提到的，如果这个类的声明中**加上了`implements Serializable`的字样它就不再是一个 `Singleton`**。无论该类使用了默认的序列化形式，还是自定义的序列化形式，都没有关系；也跟它是否提供了显式的 `readObject`方法无关。**任何一个 `readObject`方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例**。



**`readResolve` 特性允许你用 `readObject` 创建的实例代替另一个实例。** 对于一个正在被反序列化的对象，如果它的类定义了一个 `readResolve`方法，并且具备正确的声明，那么在反序列化之后，新建对象上的 `readResolve` 方法就会被调用。**然后，该方法返回的对象引用将被返回，取代新建的对象**。在*这个特性的绝大多数用法中，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收的对象。*



如果 `Elvis` 类要实现 `Serializable` 接口，下面的 `readResolve` 方法就足以保证它的 `Singleton` 属性

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-08-56_r84.png)



**该方法忽略了被反序列化的对象，只返回「该类初始化时」创建的那个特殊的 Elvis 实例**。因此，**Elvis 实例的序列化形式并不需要包含任何实际的数据**；所有的实例域都应该被声明为`transient`的。**事实上，如果依赖 `readResolve` 进行实例控制，带有对象引用类型的所有实例域则都必须声明为 `transient` 的。**否则，那种破釜沉舟式的攻击者，就有可能在 `readResolve`方法被运行之前，保护指向反序列化对象的引用，采用的方法类似于在 Item 76 中提到过的 `MutablePeriod` 攻击。

这种攻击有点复杂，但是背后的思想却很简单。**如果 `Singleton` 包含一个非 `transient` 的对象引用域，这个域的内容就可以在 `Singleton` 的 `readResolve`方法运行之前被反序列化。当对象引用城的内容被反序列化时，它就允许一个精心制作的流「盗用」指向最初被反序列化的 `Singleton` 的引用。**



以下是它更详细的工作原理。首先，编写一个“盜用者”类，它既有 `readResolver` 方法，又有实例域，**实例域指向被序列化的 `Singleton` 的引用，“盗用者”类就“潜伏”在其中**。在序列化流中，用“盜用者”类的实例代替 `Singleton` 的非 `transient`域。你现在就有了一个循环： `Singleton`包含“盗用者”类，“盗用者”类则引用该 `Singleton`。



由于 `Singleton` 包含“盗用者”类，当这个 `Singleton` 被反序列化时，“盗用者”类的`readResolve`方法先运行。因此，当“盗用者”的 `readResolve` 方法运行时，它的实例域仍然引用被部分反序列化（并且也还没有被解析）的 `Singleton`。



“盗用者”的 `readResolve`方法从它的实例域中**将引用复制到静态域中**，以便该引用可以在`readResolve`方法运行之后被访间到。然后这个方法为它所藏身的那个域返回一个正确的类型值。如果没有这么做，当序列化系统试着将“盗用者”引用保存到这个域中时，VM 就会抛出`ClassCastException` 为了更具体地说明这一点，我们来考虑下面这个有问题的 `Singleton`：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-09-47_r71.png)



下面是个“盜用者”类，是根据上述的描述构造的：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-10-09_r83.png)





最后，这是一个不完整的程序，**它反序列化一个手工制作的流，为那个有缺陷的 `Singleton` 产生两个截然不同的实例。**这个程序中*省略了反序列化方法*：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-10-34_r88.png)



运行这个程序会产生下列输出，最终证明可以创建两个截然不同的 `Elvis` 实例（包含两种不同的音乐品位）



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-11-00_r95.png)



通过将 `favorites` 域声明为 `transient`，可以修正这个问题，但是最好把 Elvis 做成是一个单元素的枚举类型进行修正。**从历史上看， `readResolve` 方法被用于所有可序列化的实例受控的类。自从Java1.5发行版本以来，它就不再是在可序列化的类中维持实例控制的最佳方法了。**就如 `ElvisStealer` 攻击所示范的，这种方法很脆弱，需要万分谨慎。



如果反过来，你**将一个可序列化的实例受控的类编写成「枚举」，就可以绝对保证除了所声明的常量之外，不会有别的实例。**JVM对此提供了保障，这一点你可以确信无疑。从你这方面来讲，并不需要特别注意什么。以下是把 Elvis写成枚举的例子



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-22-11-26_r8.png)



**用 `readResolve` 进行实例控制并不过时。如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，你就无法将类表示成一个枚举类型。**



`readResolve` 的可访问性很重要。如果把 `readResolve` 方法放在一个 `final` 类上，它就应该是**私有**的。如果把 `readresolver` 方法放在一个非 `final` 的类上，**就必须认真考虑它可访问性**。如果它是私有的，就不适用于任何子类。如果它是包级私有的，就只适用于同一个包中的子类。如果它是受保护的或者公有的，就适用于所有没有覆盖它的子类。如果`readResolve`方法是受保护的或者公有的，并且子类没有覆盖它，对序列化过的子类实例进行反序列化，就会产生一个超类实例，这样有可能导致 `ClassCastException`异常。



总而言之，你应该尽可能地使用「**枚举类型来**」实施实例控制的约束条件。**如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个 `readResolver` 方法，并确保该类的所有实例域都为基本类型，或者是 `transient` 的。**