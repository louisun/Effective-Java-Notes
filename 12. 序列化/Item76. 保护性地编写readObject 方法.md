# Item76. 保护性地编写readObject 方法



Item 39 介绍了一个「不可变日期范围」类，包含私有 Date 域。该类通过在其构造器和访问方法中「保护性」地拷贝 Date 对象，极力维护其约束条件和不可变性。

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-51-46_r38.png)

假设你决定要把这个类**做成可序列化的**。因为 Period对象的物理表示法正好反映了它的逻辑数据内容，所以，使用默认的序列化形式并没有什么不合理的（见第75条）。因此，为了使这个类成为可序列化的，似乎你所需要做的也就是在类的声明中增加 `implements Serializable`字样。**然而，如果你真的这样做，那么这个类将不再保证它的关键约束了。**



问题在于， **`readObject` 方法实际上相当于另一个公有的构造器，如同其他的构造器一样，它也要求注意同样的所有注意事项。构造器必须检查其参数的有效性，并且在必要的时候对参数进行保护性拷贝**，同样地， `readObject` 方法也需要这样做。如果 `readObject` 方法无法做到这两者之一，对于攻击者来说，要违反这个类的约束条件相对就比较简单了。



**不严格地说，  `readObject` 是一个“用字节流作为唯一参数”的构造器。**在正常使用的情况下，对一个正常构造的实例进行序列化可以产生字节流。但是，**当面对一个人工仿造的字节流时，  `readObject` 产生的对象会违反它所属的类的约束条件，这时问题就产生了。**假设我们仅仅在 `Period` 类的声明中加上了“`implements Serializable`”宇样。那么，这个不完整的程序将产生一个 `Period` 实例，它的结束时间比起始时间还要早：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-54-39_r8.png)



被用来初始化 `serializedForm` 的`byte`数组常量是这样产生的：**首先对一个正常的 Period 实例进行序列化，然后对得到的字节流进行手工编辑。对于**这个例子而言，字节流的细节并不重要，但是如果你很好奇的话，可以在《Java Object Serialization Specification》中查到有关**序列化字节流格式**的描述信息。只要把 Period声明成可序列化的，就会使我们创建出违反其类约束条件的对象。



为了修正这个问题，你**可以为 `Period` 提供一个  `readObject` 方法，该方法首先调用`defaultReadobject`，然后检查被反序列化之后的对象的有效性**。如果有效性检查失败 `readObject` 方法就抛出一个 `InvalidObjectException`异常，使反序列化过程不能成功地完成：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-55-25_r71.png)



尽管这样的修正避免了攻击者创建无效的 `Period` 实例，但是，这里仍然隐藏着一个更为微妙的问题。通**过伪造字节流，要想创建可变的 Period 实例仍是有可能的**，做法是：字节流以个有效的 `Period` 实例开头，然后附加上两个额外的引用，指向 `Period` 实例中的两个私有的`Date`域。攻击者从 `ObjectInputStream`中 读取 `Period` 实例，然后**读取附加在其后面的“恶意编制的对象引用”**。这些对象引用使得攻击者能够访问到 `Period` 对象内部的私有`Date`域所引用的对象。**通过改变这些`Date`实例，攻击者可以改变 `Period` 实例**。下面的类演示了这种攻击：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-55-53_r43.png)



运行下面的程序可以看到攻击结果：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-56-09_r28.png)

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-57-46_r59.png)

虽然 `Period` 实例被创建之后，它的约束条件没有被破坏，**但是要随意地修改它的内部组件仍然是有可能的**。一旦攻击者获得了一个可变的 `Period` 实例，他就可以将这个实例传递给一个“安全性依赖于 `Period` 的不可变性”的类，从而造成更大的危害。这种推断并不牵强：实际上有许多类的安全性就是依赖于 String 的不可变性。



**问题的根源在于， `Period` 的 `readObject` 方法并没有完成足够的保护性拷贝。**当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如釆哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。因此，对于每个可序列化的不可变类，如果它包含了私有的可变组件，那么在它的 `readObject` 方法中，必须要对这些组件进行**保护性拷贝**。下面的 `readObject` 方法可以确保 `Period` 的约束条件不会遭到破坏，以保持它的不可变性：



![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-58-08_r85.png)



注意，**保护性拷贝是在有效性检查之前进行的**，而且，我们没有使用 `Date` 的 `clone` 方法来执行保护性拷贝。这两个细节对于保护 `Period` 免受攻击是必要的。同时也要注意到，对于 `final` 域，保护性拷贝是不可能的。为了使用 `readObject` 方法，我们必须要将 `start` 和 `end` 域做成非 `final` 的。这是很遗憾的，但是这还算是相对比较好的做法。有了这个新的`readObject`方法，并去掉了`star`和`end`域的 `final` 修饰符之后， `MutablePeriod`类将不再有效。此时，上面的攻击程序会产生这样的输出：

![](https://bucket-1255905387.cos.ap-shanghai.myqcloud.com/2019-01-30-19-58-40_r60.png)



在 Java1.4 发行版本中，**为了阻止恶意的对象引用攻击，同时节省保护性拷贝的开销**，在 `ObjectOutputStream`中 增加了 `writeUnshared` 和 `readUnshared` 方法。遗憾的是这些方法都很容易受到复杂的攻击，即本质上与 Item 77 中所述的 Elvis stealer 攻击相似的攻击。不要使用 `writeUnshared` 和 `readUnshared`方法。**它们通常比保护性拷贝更快，但是它们不提供必要的安全性保护**。



有一个简单的「石蕊测试」，可以用来确定默认的 `readObject` 方法是否可以被接受。**测试方法：增加一个公有的构造器，其参数对应于该对象中每个非 `transient` 的域，并且无论参数的值是什么，都是不进行检查就可以保存到相应的域中的。**对于这样的做法，你是否会感到很舒适？如果你对这个问题的回答是否定的，就必须提供一个显式的 `readObject`方法，并且它必须执行构造器所要求的所有「**有效性检查**」和「**保护性拷贝**」。另一种方法是，可以使用「**序列化代理模式**」，见 Item 78。



从对于非 `final` 的可序列化的类，在 `readObject` 方法和构造器之间还有其他类似的地方。 `readObject` 方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以（见 Item 17）。如果违反了这条规则，并且覆盖了该方法，被覆盖的方法将在子类的状态被反序列化之前先运行。程序很可能会失败。**总而言之，每当你编写  `readObject` 方法的时候，都要这样想：你正在编写一个公有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。不要假设这个字节流定代表着一个真正被序列化过的实例。**虽然在本条目的例子中，类使用了默认的序列化形式，但是，所有讨论到的有可能发生的问题也同样适用于使用自定义序列化形式的类。下面以摘要的形式给出一些指导方针，有助于编写出更加健壮的  `readObject` 法：



- **对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。**不可变类的可变组件就属于这一类别。
- **对于任何约束条件，如果检查失败，则抛出一个 `InvalidobjectException` 异常。这些检查动作应该跟在所有的「保护性拷贝之后」。**
- **如果整个对象图在「被反序列化之后」必须进行「验证」，就应该使用 `ObjectInputValidation` 接口**。
- **无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。**



